{"ast":null,"code":"// src/queriesObserver.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { QueryObserver } from \"./queryObserver.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { replaceEqualDeep } from \"./utils.js\";\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nvar QueriesObserver = class extends Subscribable {\n  #client;\n  #result;\n  #queries;\n  #options;\n  #observers;\n  #combinedResult;\n  #lastCombine;\n  #lastResult;\n  constructor(client, queries, options) {\n    super();\n    this.#client = client;\n    this.#options = options;\n    this.#queries = [];\n    this.#observers = [];\n    this.#result = [];\n    this.setQueries(queries);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n    }\n  }\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    this.#observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n  setQueries(queries, options, notifyOptions) {\n    this.#queries = queries;\n    this.#options = options;\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers;\n      const newObserverMatches = this.#findMatchingObservers(this.#queries);\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n      this.#observers = newObservers;\n      this.#result = newResult;\n      if (!this.hasListeners()) {\n        return;\n      }\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n      this.#notify();\n    });\n  }\n  getCurrentResult() {\n    return this.#result;\n  }\n  getQueries() {\n    return this.#observers.map(observer => observer.getCurrentQuery());\n  }\n  getObservers() {\n    return this.#observers;\n  }\n  getOptimisticResult(queries, combine) {\n    const matches = this.#findMatchingObservers(queries);\n    const result = matches.map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n    return [result, r => {\n      return this.#combineResult(r ?? result, combine);\n    }, () => {\n      return matches.map((match, index) => {\n        const observerResult = result[index];\n        return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult, accessedProp => {\n          matches.forEach(m => {\n            m.observer.trackProp(accessedProp);\n          });\n        }) : observerResult;\n      });\n    }];\n  }\n  #combineResult(input, combine) {\n    if (combine) {\n      if (!this.#combinedResult || this.#result !== this.#lastResult || combine !== this.#lastCombine) {\n        this.#lastCombine = combine;\n        this.#lastResult = this.#result;\n        this.#combinedResult = replaceEqualDeep(this.#combinedResult, combine(input));\n      }\n      return this.#combinedResult;\n    }\n    return input;\n  }\n  #findMatchingObservers(queries) {\n    const prevObserversMap = new Map(this.#observers.map(observer => [observer.options.queryHash, observer]));\n    const observers = [];\n    queries.forEach(options => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options);\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n      if (match) {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        });\n      } else {\n        const existingObserver = this.#observers.find(o => o.options.queryHash === defaultedOptions.queryHash);\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: existingObserver ?? new QueryObserver(this.#client, defaultedOptions)\n        });\n      }\n    });\n    return observers.sort((a, b) => {\n      return queries.findIndex(q => q.queryHash === a.defaultedQueryOptions.queryHash) - queries.findIndex(q => q.queryHash === b.defaultedQueryOptions.queryHash);\n    });\n  }\n  #onUpdate(observer, result) {\n    const index = this.#observers.indexOf(observer);\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result);\n      this.#notify();\n    }\n  }\n  #notify() {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult;\n      const newResult = this.#combineResult(this.#result, this.#options?.combine);\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach(listener => {\n            listener(this.#result);\n          });\n        });\n      }\n    }\n  }\n};\nexport { QueriesObserver };","map":{"version":3,"mappings":"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","names":["notifyManager","QueryObserver","Subscribable","replaceEqualDeep","difference","array1","array2","filter","x","includes","replaceAt","array","index","value","copy","slice","QueriesObserver","constructor","client","queries","options","setQueries","onSubscribe","listeners","size","forEach","observer","subscribe","result","onUnsubscribe","destroy","Set","notifyOptions","batch","prevObservers","newObserverMatches","match","setOptions","defaultedQueryOptions","newObservers","map","newResult","getCurrentResult","hasIndexChange","some","length","hasListeners","getQueries","getCurrentQuery","getObservers","getOptimisticResult","combine","matches","r","observerResult","notifyOnChangeProps","trackResult","accessedProp","m","trackProp","input","prevObserversMap","Map","queryHash","observers","defaultedOptions","defaultQueryOptions","get","push","existingObserver","find","o","sort","a","b","findIndex","q","indexOf","previousResult","listener"],"sources":["C:\\Users\\Razeen Ali\\499_capstone\\imageUpload\\react-node-s3-image-upload\\frontend\\node_modules\\@tanstack\\query-core\\src\\queriesObserver.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\ntype CombineFn<TCombinedResult> = (\n  result: Array<QueryObserverResult>,\n) => TCombinedResult\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: CombineFn<TCombinedResult>\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #options?: QueriesObserverOptions<TCombinedResult>\n  #observers: Array<QueryObserver>\n  #combinedResult?: TCombinedResult\n  #lastCombine?: CombineFn<TCombinedResult>\n  #lastResult?: Array<QueryObserverResult>\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions<any, any, any, any, any>>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#options = options\n    this.#queries = []\n    this.#observers = []\n    this.#result = []\n\n    this.setQueries(queries)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.#queries = queries\n    this.#options = options\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): Array<QueryObserverResult> {\n    return this.#result\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result, combine)\n      },\n      () => {\n        return matches.map((match, index) => {\n          const observerResult = result[index]!\n          return !match.defaultedQueryOptions.notifyOnChangeProps\n            ? match.observer.trackResult(observerResult, (accessedProp) => {\n                // track property on all observers to ensure proper (synchronized) tracking (#7000)\n                matches.forEach((m) => {\n                  m.observer.trackProp(accessedProp)\n                })\n              })\n            : observerResult\n        })\n      },\n    ]\n  }\n\n  #combineResult(\n    input: Array<QueryObserverResult>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): TCombinedResult {\n    if (combine) {\n      if (\n        !this.#combinedResult ||\n        this.#result !== this.#lastResult ||\n        combine !== this.#lastCombine\n      ) {\n        this.#lastCombine = combine\n        this.#lastResult = this.#result\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input),\n        )\n      }\n\n      return this.#combinedResult\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObserversMap = new Map(\n      this.#observers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const observers: Array<QueryObserverMatch> = []\n\n    queries.forEach((options) => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const match = prevObserversMap.get(defaultedOptions.queryHash)\n      if (match) {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: match,\n        })\n      } else {\n        const existingObserver = this.#observers.find(\n          (o) => o.options.queryHash === defaultedOptions.queryHash,\n        )\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer:\n            existingObserver ??\n            new QueryObserver(this.#client, defaultedOptions),\n        })\n      }\n    })\n\n    return observers.sort((a, b) => {\n      return (\n        queries.findIndex(\n          (q) => q.queryHash === a.defaultedQueryOptions.queryHash,\n        ) -\n        queries.findIndex(\n          (q) => q.queryHash === b.defaultedQueryOptions.queryHash,\n        )\n      )\n    })\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result)\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult\n      const newResult = this.#combineResult(\n        this.#result,\n        this.#options?.combine,\n      )\n\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach((listener) => {\n            listener(this.#result)\n          })\n        })\n      }\n    }\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n"]},"metadata":{},"sourceType":"module"}